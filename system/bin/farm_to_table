#!/bin/bash

# farm_to_table
# Matt Allbright
# This script will automatically pull data from Hermes for studies and then sort
# individual files into the proper study directory. It is based on ideas from
# previous "convertit"-type scripts used in the lab.

#Functions

# Function necessary to figure out the intracacies of each study
# Why they were set up in completely different ways, and in completely different
# structures, is beyond me
getInfo() {
  if [ $study = "tbimodel" ] || [ $study = "TBIMODEL" ]; then
    longitudinalBool=0
    # Forcing new prefix to TBIMODEL_000 standard
    studyPrefix="TM"
    boldValues=("resting")
    magPhaseBool=1
    dtiBool=1
  elif [ $study = "BLHC" ]; then
    longitudinalBool=0
    studyPrefix="BLHC"
    boldValues=("resting" "msit" "nback")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "BL2" ]; then
    longitudinalBool=1
    studyPrefix="BL2_"
    boldValues=("resting" "msit" "nback")
    magPhaseBool=0
    dtiBool=1
  elif [ $study = "blt" ]; then
    longitudinalBool=1
    studyPrefix="BL"
    boldValues=("resting" "msit" "nback")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "BLPTSD" ]; then
    longitudinalBool=1
    studyPrefix="BLPTSD_"
    boldValues=("resting" "anticipation" "bmat_fear" "bmat_happy" "dot_probe" "fear_conditioning")
    magPhaseBool=0
    dtiBool=1
  elif [ $study = "EWM" ]; then
    longitudinalBool=0
    studyPrefix="EWM_"
    boldValues=("resting" "faces" "iaps")
    magPhaseBool=0
    dtiBool=0
  elif [ $study = "EIT" ]; then
    longitudinalBool=0
    studyPrefix="EIT_"
    boldValues=()
    magPhaseBool=0
    dtiBool=0
  elif [ $study = "emot" ]; then
    longitudinalBool=0
    studyPrefix="emot"
    boldValues=("anger" "emotdist" "faceint" "fear" "food" "happy" "memsupp" "sceneint" "trust" "resting")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "ICBT" ]; then
    longitudinalBool=1
    studyPrefix="ICBT"
    boldValues=("eit")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "Cogr" ]; then
    longitudinalBool=0
    studyPrefix="CR"
    boldValues=("resting" "msit" "nback")
    magPhaseBool=0
    dtiBool=0
  elif [ $study = "Cogr2" ]; then
    longitudinalBool=0
    studyPrefix="CRG_"
    boldValues=("resting" "msit" "nback")
    magPhaseBool=0
    dtiBool=0
  else
    echo "Study not found: $study"
    exit 1
  fi
}

# Just grabs data from Hermes
HermesFetch(){
  # Bunch of error checking before forcing a fetch
  if [ ! -d /Hermes ]; then
    echo "Hermes directory doesn't exist!"
    exit 1
  elif [ -z "$(ls -A /Hermes)" ]; then
    echo "Hermes isn't mounted properly!"
    exit 1
  fi
  if [ ! -d $studyDir ]; then
    echo "$study directory doesn't exist!"
    exit 1
  elif [ -z "$(ls -A $studyDir)" ]; then
    echo "$study isn't mounted properly!"
    exit 1
  fi

  if [ ! -d $particRawDir ]; then
    # Fetch data from RAW for $partic
    echo "Locating data for $partic..."
    # Strip partic to just the numbers
    particNumber=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
    # Find folder where number pattern is present
    rawCheckString=`find /Hermes/"$study"_scans -maxdepth 1 -iname "*$particNumber*" -print | sort | head -1`
    if [[ "${rawCheckString}" = *"$particNumber"* ]]; then
      mkdir -p $particRawDir
      osirixDir=`find /Hermes/"$study"_scans -maxdepth 1 -iname "*$particNumber*" -print | sort | head -1` #| sed 's/.*\///'
      echo "Copying data from shared mount..."
      cp -r "$osirixDir/." $particRawDir/
      dataNotFound=0
    else
      echo "No data found for $partic. Make sure Osirix data is anonymized and organized."
      dataNotFound=1
    fi
  else
    if [ $bypassOverwrite -eq 0 ]; then
      echo "The RAW directory already exists for this user. Would you like to copy"
      echo "anyway? Typically RAW_data can be overwritten without consequence."
      read rawResponse
    fi
    if [[ "$rawResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
      # Fetch data from RAW for $partic
      echo "Locating data for $partic..."
      # Strip partic to just the numbers
      particNumber=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
      # Find folder where number pattern is present
      rawCheckString2=`find /Hermes/"$study"_scans -maxdepth 1 -iname "*$particNumber*" -print | sort | head -1`
      if [[ "${rawCheckString2}" = *"$particNumber"* ]]; then
        osirixDir=`find /Hermes/"$study"_scans -maxdepth 1 -iname "*$particNumber*" -print | sort | head -1` #| sed 's/.*\///'
        echo "Found $particNumber at $osirixDir"
        echo "Copying data from shared mount..."
        cp -r "$osirixDir/." $particRawDir/
        dataNotFound=0
      else
        echo "No data found for $partic. Make sure Osirix data is anonymized and organized."
        dataNotFound=1
      fi
      if [ $overwriteTriggerCount -eq 0 ]; then
        overwriteTriggerCount=$((overwriteTriggerCount + 1))
        echo "It appears that there are a number of overwritable RAW directories which you have chosen."
        echo "Would you like to overwrite all future RAW directories and bypass the prompt?"
        read overwriteResponse
        if [[ "$rawResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
          bypassOverwrite=1
        fi
      fi
      overwriteTriggerCount=$((overwriteTriggerCount + 1))
    else
      echo "Data will not be modified. Continuing with structure..."
      dataNotFound=0
    fi
  fi
}

overwriteTriggerCount=0
overwriteIndivCount=0
overwriteLongCount=0
bypassOverwrite=0
bypassIndivOverwrite=0

while [ -n "$1" ]; do
case "$1" in
-l) legacyBool="True" ;;
*) echo "Option $1 not recognized" ;;
esac
shift
done

# Start program

if [ "$legacyBool" = "True" ]; then
  echo "LEGACY MODE ACTIVE"
else
  legacyBool="False"
fi

echo "Welcome to Farm to Table."
echo "Farm to Table takes images and data from the machine Hermes and sorts"
echo "these files into a structured system for use with FSL, FreeSurfer, and"
echo "other real cool software."

echo "First, we need a study."
# New menu variables
studySelectArr=(/data/* "New study")

# Create menu
select studyDir in "${studySelectArr[@]}"; do
  case $studyDir in
    "New study")
      echo "Creating new study..."
      echo "This system is not implemented yet."
      newStudyBool=1
      break
      ;;
    *)
      echo "Selected $studyDir"
      newStudyBool=0
      break
      ;;
  esac
done

if [ $newStudyBool -eq 1 ]; then
  echo "What is the name of the study you would like to create? (e.g. EIT, tbimodel)"
  echo "Please refrain from using spaces or non-letter characters."
  read study
  studyDir="/data/$study"
  if [ -d /data/$study ]; then
    echo "Study already exists!"
    exit 1
  else
    echo "New study system not implemented"
    exit 1
  fi
fi

study=${studyDir#*/data/}
getInfo $study

# Init array
particArr=()

echo "What are the number(s) of the participants you would like to process?"
echo "Separate each with a space (e.g. 005 006 016 185). You can also type 'all'"
echo "to run through all subjects."
read particNums # Pull the numbers as delimited variables
particReadArr=($particNums) # Shove said numbers into an array
if [ $particNums = "all" ]; then
  particNumArr=( $(ls /Hermes/"$study"_scans/ | grep -Eo '[0-9][0-9][0-9]') )
else
  particNumArr=($particNums)
fi

for partic in ${particNumArr[*]}; do
  particNum=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
  if [ "$partic" = x"$partic" ]; then
    echo "Not a valid id. Skipping.."
  else
	if [ "$legacyBool" = "True" ]; then
      particArr+=("$studyPrefix$particNum") # Clean up the numbers array by adding a prefix (eg 102 becomes TM_102)
		echo "Found $partic..."
	else
		particArr+=("$particNum") # Clean up the numbers array by adding a prefix (eg 102 stays 102)
		echo "Found $partic..."
	fi
  fi
done

IFS=$'\n'

red='\033[0;31m'
noColor='\e[0m'

# Get data from Hermes for the participant(s)
for partic in ${particArr[*]}; do
	echo "Starting download for $partic"
	if [ "$legacyBool" = "True" ]; then
	  particRawDir="$studyDir/RAW_data/$partic"
	else
	  particRawDir="$studyDir/RAW_data/$studyPrefix$partic"
	fi
	echo -e "${red}ParticRawDir is $particRawDir${noColor}"
	HermesFetch $partic



  if [ $dataNotFound -eq 1 ]; then
    echo "-----------------------------------------------"
    echo "No Osirix data found for $partic. Moving on..."
    echo "-----------------------------------------------"
  else
    # Create directory structure
    if [ "$legacyBool" = "True" ]; then
      particDir=$studyDir/indiv_analysis/$partic
    else
      particNum2=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
      particDir=$studyDir/BIDS_indiv_analysis/sub-$particNum2
    fi
    echo "ParticDir is $particDir"
    if [ ! -d $particDir ]; then
      echo "Creating directory for $partic"
      dirAlreadyExists=0
      mkdir -p $particDir
    else
      echo "Directory detected."
      dirAlreadyExists=1
    fi

################################################################################
    # Longitudinal structuring
    if [ $longitudinalBool -eq 1 ]; then
      echo "Logitudinal study detected."
      # Check baseline directory existence
      baseCheckString=`find $particRawDir -maxdepth 2 -iname "*_BV" -print | sort | head -1`
      if [[ ! "$baseCheckString" =~ "$partic" ]]; then
        echo "*_BV not found."
        baseCheckString=`find $particRawDir -maxdepth 2 -iname "*_BL" -print | sort | head -1`
        if [[ ! "$baseCheckString" =~ "$partic" ]]; then
          echo "*_BL not found."
          baseCheckString=`find $particRawDir -maxdepth 2 -iname "*_baseline" -print | sort | head -1`
        fi
      fi
      echo "baseCheckString is $baseCheckString"
      if [[ "$baseCheckString" = *"$partic"* ]]; then
        echo "Baseline detected."
        baselineRawDir=`find $particRawDir -maxdepth 2 -iname "*_BV" -print | sort | head -1`
        if [[ ! "$baselineRawDir" =~ "$partic" ]]; then
          baselineRawDir=`find $particRawDir -maxdepth 2 -iname "*_BL" -print | sort | head -1`
          if [[ ! "$baselineRawDir" =~ "$partic" ]]; then
            baselineRawDir=`find $particRawDir -maxdepth 2 -iname "*_baseline" -print | sort | head -1`
          fi
        fi
        echo -e "${red}BaselineRawDir is $baselineRawDir${noColor}"
        if [ $dirAlreadyExists -eq 1 ]; then
          if [ $bypassIndivOverwrite -eq 0 ]; then
            echo "The indiv_analysis directory already exists."
            echo "Would you like to copy and possibly overwrite your Baseline indiv_analysis images?"
            read overwriteBaseline
          elif [ $bypassIndivOverwrite -eq 1 ]; then
            baselineBool=1
          fi
          if [[ "$overwriteBaseline" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
            baselineBool=1
            if [ $overwriteIndivCount -eq 0 ]; then
              overwriteIndivCount=$((overwriteIndivCount + 1))
              echo "It appears that there are a number of overwritable indiv_analysis directories which you have chosen."
              echo "Would you like to overwrite all future indiv_analysis directories and bypass the prompt?"
              read overwriteIndivResponse
              if [[ "$overwriteIndivResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
                bypassIndivOverwrite=1
              fi
            fi
            overwriteIndivCount=$((overwriteIndivCount + 1))
          fi
        else
          baselineBool=1
        fi
      else
        echo "######Baseline not detected.######"
        baselineBool=0
      fi
      # Check post-treament directory existence
      postCheckString=`find $particRawDir -maxdepth 2 -iname "*_PTX" -print | sort | head -1`
      echo "postCheckString is $postCheckString"
      if [[ ! "$postCheckString" =~ "$partic" ]]; then
        echo "*_PTX not found."
        postCheckString=`find $particRawDir -maxdepth 2 -iname "*_posttx" -print | sort | head -1`
      fi
      if [[ "${postCheckString}" = *"$partic"* ]]; then
        echo "PostTX detected."
        postTXRawDir=`find $particRawDir -maxdepth 2 -iname "*_PTX" -print | sort | head -1`
        if [[ ! "$postTXRawDir" =~ "$partic" ]]; then
          postTXRawDir=`find $particRawDir -maxdepth 2 -iname "*_posttx" -print | sort | head -1`
        fi
        echo -e "${red}PostTXRawDir is $postTXRawDir${noColor}"
        if [ $dirAlreadyExists -eq 1 ]; then
          if [ $bypassIndivOverwrite -eq 0 ]; then
            echo "The indiv_analysis directory already exists."
            echo "Would you like to copy and possibly overwrite your PostTX indiv_analysis images?"
            read overwritePostTX
          elif [ $bypassIndivOverwrite -eq 1 ]; then
            postTXBool=1
          fi
          if [[ "$overwritePostTX" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
            postTXBool=1
            if [ $overwriteIndivCount -eq 0 ]; then
              overwriteIndivCount=$((overwriteIndivCount + 1))
              echo "It appears that there are a number of overwritable indiv_analysis directories which you have chosen."
              echo "Would you like to overwrite all future indiv_analysis directories and bypass the prompt?"
              read overwriteIndivResponse
              if [[ "$overwriteIndivResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
                bypassIndivOverwrite=1
              fi
            fi
            overwriteIndivCount=$((overwriteIndivCount + 1))
          fi
        else
          postTXBool=1
        fi
      else
        echo "###### PostTX not detected. ######"
        postTXBool=0
      fi

      if [ $baselineBool -eq 1 ]; then
        echo "Running for Baseline."
      elif [ $baselineBool -eq 0 ]; then
        echo "###### Not running for Baseline ######"
      else
        echo "Non-logitudinal detected"
      fi

      if [ $postTXBool -eq 1 ]; then
        echo "Running for PostTX."
      elif [ $postTXBool -eq 0 ]; then
        echo "###### Not running for PostTX ######"
      else
        echo "Non-logitudinal detected"
      fi

      # Baseline Anatomical
      if [ $baselineBool -eq 1 ]; then
        anatDirArr=($(find $baselineRawDir -maxdepth 2 -iname "T1_MPRAGE_1MM*" -print | sort))
        anatNum=1
        if [ "$legacyBool" = "True" ]; then
          if [ ! -d $particDir/anatomicals/Baseline ]; then
            mkdir -p $particDir/anatomicals/Baseline
          fi
          for anatomical in ${anatDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
            dcm2niix -f "$partic"_anatomical_$anatNum -o $particDir/anatomicals/Baseline "${anatomical}"
            anatNum=$((anatNum+1))
          done
        else
          if [ ! -d $particDir/ses-Pre/anat ]; then
            mkdir -p $particDir/ses-Pre/anat
          fi
          for anatomical in ${anatDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
			# Matt: Original had the Baseline T1s getting numbered as run-1 while PostTX was run-01. Changed for parity..
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_run-0$anatNum"_T1w" -o $particDir/ses-Pre/anat "${anatomical}"
            anatNum=$((anatNum+1))
          done
        fi
      fi

      # PostTX Anatomical
      if [ $postTXBool -eq 1 ]; then
        anatDirArr=($(find $postTXRawDir -maxdepth 2 -iname "T1_MPRAGE_1MM*" -print | sort))
        anatNum=1
        if [ "$legacyBool" = "True" ]; then
          if [ ! -d $particDir/anatomicals/PostTX ]; then
            mkdir -p $particDir/anatomicals/PostTX
          fi
          for anatomical in ${anatDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
            dcm2niix -f "$partic"_anatomical_0$anatNum -o $particDir/anatomicals/PostTX "${anatomical}"
            anatNum=$((anatNum+1))
          done
        else
          if [ ! -d $particDir/ses-Post/anat ]; then
            mkdir -p $particDir/ses-Post/anat
          fi
          for anatomical in ${anatDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_run-0$anatNum"_T1w" -o $particDir/ses-Post/anat "${anatomical}"
            anatNum=$((anatNum+1))
          done
        fi
      fi

      # Baseline FLAIR
      if [ $baselineBool -eq 1 ]; then
        anatBDirArr=($(find $baselineRawDir -maxdepth 2 -iname "*FLAIR?axial*" -print | sort))
        anatNumB=1
        if [ "$legacyBool" = "True" ]; then
          if [ ! -d $particDir/anatomicals/Baseline ]; then
            mkdir -p $particDir/anatomicals/Baseline
          fi
          for anatomical in ${anatBDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
            dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals/Baseline "${anatomical}"
            anatNumB=$((anatNumB+1))
          done
        else
          if [ ! -d $particDir/ses-Pre/anat ]; then
            mkdir -p $particDir/ses-Pre/anat
          fi
          for anatomical in ${anatBDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
			#Matt: Your version originally had anatNum, so the FLAIRs were getting numbered based on the T1s.
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_run-0$anatNumB"_FLAIR" -o $particDir/ses-Pre/anat "${anatomical}"
            anatNumB=$((anatNumB+1))
          done
        fi
      fi

      # In the case that T2 FLAIR and Flair axial are the same, uncomment and fix the below

      # if [ $baselineBool -eq 1 ]; then
      #   anatB2DirArr=($(find $baselineRawDir -maxdepth 2 -iname "*T2?FLAIR*" -print | sort))
      #   anatNumB=1
      #   if [ $anatB2DirArr = $anatBDirArr ]; then
      #     echo "Flair Axial is already run..."
      #   else
      #     if [ "$legacyBool" = "True" ]; then
      #       if [ ! -d $particDir/anatomicals/Baseline ]; then
      #         mkdir -p $particDir/anatomicals/Baseline
      #       fi
      #       for anatomical in ${anatBDirArr[@]}; do
      #         echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
      #         dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals/Baseline "${anatomical}"
      #         anatNumB=$((anatNumB+1))
      #       done
      #     else
      #       if [ ! -d $particDir/ses-Pre/anat ]; then
      #         mkdir -p $particDir/ses-Pre/anat
      #       fi
      #       for anatomical in ${anatBDirArr[@]}; do
      #         echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
      #         dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_run-0$anatNumB"_FLAIR" -o $particDir/ses-Pre/anat "${anatomical}"
      #         anatNumB=$((anatNumB+1))
      #       done
      #     fi
      #   fi

      # PostTX FLAIR
      if [ $postTXBool -eq 1 ]; then
        anatBDirArr=($(find $postTXRawDir -maxdepth 2 -iname "*FLAIR*" -print | sort))
        anatNumB=1
        if [ "$legacyBool" = "True" ]; then
          if [ ! -d $particDir/anatomicals/PostTX ]; then
            mkdir -p $particDir/anatomicals/PostTX
          fi
          for anatomical in ${anatBDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum2 located in $anatomical"
            dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals/PostTX "${anatomical}"
            anatNumB=$((anatNumB+1))
          done
        else
          if [ ! -d $particDir/ses-Post/anat ]; then
            mkdir -p $particDir/ses-Post/anat
          fi
          for anatomical in ${anatBDirArr[@]}; do
            echo "Running dcm2nii for Anatomical $anatNum2 located in $anatomical"
			#Matt: Your version originally had anatNum, so the FLAIRs were getting numbered based on the T1s.
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_run-0$anatNumB"_FLAIR" -o $particDir/ses-Post/anat "${anatomical}"
            anatNumB=$((anatNumB+1))
          done
        fi
      fi

      # Checks if bold array is empty
      if [ ${#boldValues[@]} -eq 0 ]; then
        echo "No BOLD tasks for $partic"
      else
        echo "Running BOLD for $partic"
        # Run bold sorting
        for bold_type in ${boldValues[*]}; do
          # Checks postTX bool
          echo "Running $bold_type"
          if [ $baselineBool -eq 1 ]; then
            # If task directory exists run dcm2niix on it
            baseCheckString2=`find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
            if [[ "${baseCheckString2}" = *"${partic}"* ]]; then
              echo "Check passed..."
              if [ "$legacyBool" = "True" ]; then
                # Makes directory if it doesn't exist
                if [ ! -d $particDir/bold/${bold_type}/Baseline ]; then
                  mkdir -p $particDir/bold/${bold_type}/Baseline
                fi
                # Takes latest directory with bold
                baseboldDirRun=($(find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort))
                baseBoldNum=1
                echo -e "${red}Baseline BOLD dir is $baselineRawDir${noColor}"
                for bold_run in ${baseboldDirRun}; do
                  dcm2niix -f "$partic"_${bold_type}_run-0$baseBoldNum -o $particDir/bold/${bold_type}/Baseline "$baseboldDirRun"
                  baseBoldNum=$((baseBoldNum+1))
                done
              else
                if [ ! -d $particDir/ses-Pre/func ]; then
                  mkdir -p $particDir/ses-Pre/func
                fi
                # Takes latest directory with bold
                baseboldDirRun=($(find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort))
                echo -e "${red}Baseline BOLD dir is $baselineRawDir${noColor}"
                baseBoldNum=1
                for bold_run in ${baseboldDirRun}; do
                  dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_task-${bold_type}_run-0$baseBoldNum"_bold" -o $particDir/ses-Pre/func "$baseboldDirRun"
                  baseBoldNum=$((baseBoldNum+1))
                done
              fi
            else
              echo "No data for $bold_type in baseline $partic directory."
            fi
          fi
          # Checks postTX bool
          if [ $postTXBool -eq 1 ]; then
            # If task directory exists run dcm2niix on it
            postCheckString2=`find $postTXRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
            if [[ "${postCheckString2}" = *"${partic}"* ]]; then
              if [ "$legacyBool" = "True" ]; then
              # Makes directory if it doesn't exist
                if [ ! -d $particDir/bold/${bold_type}/PostTX ]; then
                  mkdir -p $particDir/bold/${bold_type}/PostTX
                fi
                postboldDir=($(find $postTXRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort))
                postBoldNum=1
                echo -e "${red}PostTX BOLD dir is $postboldDir${noColor}"
                for bold_runB in ${postboldDirRun}; do
                  dcm2niix -f "$partic"_${bold_type}_run-0$postBoldNum -o $particDir/bold/${bold_type}/PostTX "$postboldDirRun"
                  postBoldNum=$((postBoldNum+1))
                done
              else
                if [ ! -d $particDir/ses-Post/func ]; then
                  mkdir -p $particDir/ses-Post/func
                fi
                # Takes latest directory with bold
                postboldDir=($(find $postTXRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort))
                postBoldNum=1
                echo -e "${red}PostTX BOLD dir is $postboldDir${noColor}"
                for bold_runB in ${postboldDirRun}; do
                  dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_task-${bold_type}_run-0$postBoldNum"_bold" -o $particDir/ses-Post/func "$postboldDir"
                  postBoldNum=$((postBoldNum+1))
                done
              fi
            else
              echo "No data for $bold_type in post-treatment $partic directory."
            fi
          fi
        done
      fi

      # Baseline fieldmaps
      if [ $magPhaseBool -eq 1 ]; then
        # Running for Mag (note the sort -r)
        echo "Beginning Magnitude-Phase fieldmap conversion..."
        # Baseline
        if [ $baselineBool -eq 1 ]; then
          magBaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*field*" -print | sort -r | tail -1`
          if [ "$legacyBool" = "True" ]; then
            if [ ! -d $particDir/fieldmaps/Baseline ]; then
              mkdir -p $particDir/fieldmaps/Baseline
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -f "$partic"_Mag -o $particDir/fieldmaps/Baseline "$magBaselineDir"
          else
            if [ ! -d $particDir/ses-Pre/fmap ]; then
              mkdir -p $particDir/ses-Pre/fmap
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_magnitude1 -o $particDir/ses-Pre/fmap "$magBaselineDir"
			sed -i '/COL/ a "IndendedFor": ["func/sub-$partic_ses-Pre_task-resting_bold.nii", "func/sub-$partic_ses-Pre_task-msit_bold.nii","func/sub-$partic_ses-Pre_task-nback_bold.nii","dwi/sub-$partic_ses-Pre_dwi.nii"],' $particDir/ses-Pre/fmap/*magnitude1.json
          fi
        fi
        # PostTX
        if [ $postTXBool -eq 1 ]; then
          magPostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*field*" -print | sort -r | tail -1`
          if [ "$legacyBool" = "True" ]; then
            if [ ! -d $particDir/fieldmaps/PostTX ]; then
              mkdir -p $particDir/fieldmaps/PostTX
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -f "$partic"_Mag -o $particDir/fieldmaps/PostTX "$magPostTXDir"
          else
            if [ ! -d $particDir/ses-Post/fmap ]; then
              mkdir -p $particDir/ses-Post/fmap
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_magnitude1 -o $particDir/ses-Post/fmap "$magPostTXDir"
			sed -i '/COL/ a "IndendedFor": ["func/sub-$partic_ses-Post_task-resting_bold.nii", "func/sub-$partic_ses-Post_task-msit_bold.nii","func/sub-$partic_ses-Post_task-nback_bold.nii","dwi/sub-$partic_ses-Post_dwi.nii"],' $particDir/ses-Post/fmap/*magnitude1.json
          fi
        fi

        # Running same system for Phase
        # Baseline
        if [ $baselineBool -eq 1 ]; then
          phaseBaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
          if [ "$legacyBool" = "True" ]; then
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -f "$partic"_Phase -o $particDir/fieldmaps/Baseline "$phaseBaselineDir"
          else
            if [ ! -d $particDir/ses-Pre/fmap ]; then
              mkdir -p $particDir/ses-Pre/fmap
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_phasediff -o $particDir/ses-Pre/fmap "$phaseBaselineDir"
			sed -i '/COL/ a "IndendedFor": ["func/sub-$partic_ses-Pre_task-resting_bold.nii", "func/sub-$partic_ses-Pre_task-msit_bold.nii","func/sub-$partic_ses-Pre_task-nback_bold.nii","dwi/sub-$partic_ses-Pre_dwi.nii"],' $particDir/ses-Pre/fmap/*phasediff.json
          fi
        fi
        # PostTX
        if [ $postTXBool -eq 1 ]; then
          phasePostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
          if [ "$legacyBool" = "True" ]; then
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -f "$partic"_Phase -o $particDir/fieldmaps/PostTX "$phasePostTXDir"
          else
            if [ ! -d $particDir/ses-Post/fmap ]; then
              mkdir -p $particDir/ses-Post/fmap
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_phasediff -o $particDir/ses-Post/fmap "$phasePostTXDir"
			sed -i '/COL/ a "IndendedFor": ["func/sub-$partic_ses-Post_task-resting_bold.nii", "func/sub-$partic_ses-Post_task-msit_bold.nii","func/sub-$partic_ses-Post_task-nback_bold.nii","dwi/sub-$partic_ses-Post_dwi.nii"],' $particDir/ses-Post/fmap/*phasediff.json
          fi
        fi
      else
        echo "No Magnitude of Phase fieldmaps found for $partic"
      fi
      if [ $dtiBool -eq 1 ]; then
        echo "Beginning DTI conversion..."
        # Baseline DTI
        if [ $baselineBool -eq 1 ]; then
          baseCheckString3=`find $baselineRawDir -maxdepth 2 -iname "*A-P -*" -print | sort | tail -1`
          if [[ "${baseCheckString3}" = *"${partic}"* ]]; then
            dtiAPBaselineDir=($(find $baselineRawDir -maxdepth 2 -iname "*A-P -*" -print | sort | tail -1))
            dtiAPBaselineNum=1
            if [ "$legacyBool" = "True" ]; then
              if [ ! -d $particDir/dti/Baseline ]; then
                mkdir -p $particDir/dti/Baseline
              fi
              echo "Running dcm2nii for DTI A -> P"
              for dtiAPBaselineFile in ${dtiAPBaselineDir}; do
                dcm2niix -f "$partic"_A2P_run-0$dtiAPBaselineNum -o $particDir/dti/Baseline "$dtiAPBaselineFile"
                dtiAPBaselineNum=$((dtiAPBaselineNum+1))
              done
            else
              if [ ! -d $particDir/ses-Pre/dwi ]; then
                mkdir -p $particDir/ses-Pre/dwi
              fi
              echo "Running dcm2nii for DTI A -> P"
              for dtiAPBaselineFile in ${dtiAPBaselineDir}; do
                dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_run-0"$dtiAPBaselineNum"_dwi -o $particDir/ses-Pre/dwi "$dtiAPBaselineFile" # Follow up with Adam
                dtiAPBaselineNum=$((dtiAPBaselineNum+1))
              done
            fi

            # Running same system for DTI P -> A
            if [ -n $(find $baselineRawDir -maxdepth 2 -iname "*P-?A -*" -print | sort | tail -1) ]; then
              dtiPABaselineDir=($(find $baselineRawDir -maxdepth 2 -iname "*P-?A -*" -print | sort | tail -1))
            else
              echo "P->A file not found, searching bzero identifier"
              if [ -n $(find $baselineRawDir -maxdepth 2 -iname "*bzero_verify -*" -print | sort | tail -1) ]; then
                dtiPABaselineDir=($(find $baselineRawDir -maxdepth 2 -iname "*bzero_verify -*" -print | sort | tail -1))
                echo "Utilizing Bzero for P->A"
              fi
            fi
            dtiPABaselineNum=1
            if [ "$legacyBool" = "True" ]; then
              echo "Running dcm2nii for DTI P -> A"
              for dtiPABaselineFile in ${dtiPABaselineDir}; do
                dcm2niix -f "$partic"_P2A_run-0$dtiPABaselineNum -o $particDir/dti/Baseline "$dtiPABaselineFile"
                dtiPABaselineNum=$((dtiPABaselineNum+1))
              done
            else
              if [ ! -d $particDir/ses-Pre/fmap ]; then
                mkdir -p $particDir/ses-Pre/fmap
                mkdir -p $particDir/ses-Post/dwi
              fi
              echo "Running dcm2nii for DTI P -> A"
              for dtiPABaselineFile in ${dtiPABaselineDir}; do
                dcm2niix -b y -ba y -f sub-"$partic"_ses-Pre_run-0"$dtiPABaselineNum"_epi -o $particDir/ses-Pre/fmap "$dtiPABaselineFile"
                dtiPABaselineNum=$((dtiPABaselineNum+1))
              done
			  sed -i '/COL/ a "IndendedFor": ["func/sub-$partic_ses-Pre_task-resting_bold.nii", "func/sub-$partic_ses-Pre_task-msit_bold.nii","func/sub-$partic_ses-Pre_task-nback_bold.nii","dwi/sub-$partic_ses-Pre_dwi.nii"],' $particDir/ses-Pre/fmap/*epi.json
            fi
            if [ "$legacyBool" = "True" ]; then
              bval=`find $particDir/dti/Baseline -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
              bvec=`find $particDir/dti/Baseline -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
            else
              bval=`find $particDir/ses-Pre/dwi -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
              bvec=`find $particDir/ses-Pre/dwi -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
            fi
            if [[ "${bval}" = *"bval"* ]]; then
              if [ "$legacyBool" = "True" ]; then
                mv $bval $particDir/dti/Baseline/bvals
              else
				cp $bval $particDir/ses-Pre/sub-${partic}_ses-Pre_run0${dtiAPBaselineNum}_dwi.bval
                mv $bval $particDir/ses-Pre/dwi/bvals
              fi
            else
              echo "###### bval not found ######"
            fi
            if [[ "${bvec}" = *"bvec"* ]]; then
              if [ "$legacyBool" = "True" ]; then
                mv $bvec $particDir/dti/Baseline/bvecs
              else
				cp $bvec $particDir/ses-Pre/sub-${partic}_ses-Pre_run0${dtiAPBaselineNum}_dwi.bvec
                mv $bvec $particDir/ses-Pre/dwi/bvecs
              fi
            else
              echo "###### bvec not found ######"
            fi
          else
            echo "###### No DTI images found for $partic Baseline ######"
          fi
        fi
		
        # PostTX DTI A -> P
        if [ $postTXBool -eq 1 ]; then
          postCheckString3=`find $postTXRawDir -maxdepth 2 -iname "*A-P -*" -print | sort | tail -1`
          if [[ "${postCheckString3}" = *"$partic"* ]]; then
            dtiAPPostTXDir=($(find $postTXRawDir -maxdepth 2 -iname "*A-P -*" -print | sort | tail -1))
            dtiAPPostTXNum=1
            if [ "$legacyBool" = "True" ]; then
              if [ ! -d $particDir/dti/PostTX ]; then
                mkdir -p $particDir/dti/PostTX
              fi
              echo "Running dcm2nii for DTI A -> P"
              for dtiAPPostTXFile in ${dtiAPPostTXDir}; do
                dcm2niix -f "$partic"_A2P_run-0$dtiPAPostTXNum -o $particDir/dti/PostTX "$dtiAPPostTXFile"
                dtiAPPostTXNum=$((dtiAPPostTXNum+1))
              done
            else
              if [ ! -d $particDir/ses-Post/dwi ]; then
                mkdir -p $particDir/ses-Post/dwi
                mkdir -p $particDir/ses-Post/fmap
              fi
              echo "Running dcm2nii for DTI A -> P"
              for dtiAPPostTXFile in ${dtiAPPostTXDir}; do
                dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_run-0"$dtiAPPostTXNum"_dwi -o $particDir/ses-Post/dwi "$dtiAPBaselineDir" # Follow up with Adam
                dtiAPPostTXNum=$((dtiAPPostTXNum+1))
              done
            fi

            # Running same system for DTI P -> A
            if [ -n $(find $postTXRawDir -maxdepth 2 -iname "*P-?A -*" -print | sort | tail -1) ]; then
              dtiPAPostTXDir=($(find $postTXRawDir -maxdepth 2 -iname "*P-?A -*" -print | sort | tail -1))
            else
                echo "P__A file not found, searching bzero identifier"
                dtiPAPostTXDir=($(find $postTXRawDir -maxdepth 2 -iname "*bzero_verify -*" -print | sort | tail -1))
            fi
            if [ ! -n "$dtiPAPostTXDir" ]; then
              echo "###### A -> P and P -> A mismatch for $partic, verify folders exist. ######"
            else
              if [ "$legacyBool" = "True" ]; then
                echo "Running dcm2nii for DTI P -> A"
                dcm2niix -f "$partic"_P2A -o $particDir/dti/PostTX "$dtiPAPostTXDir"
              else
                if [ ! -d $particDir/ses-Post/fmap ]; then
                  mkdir -p $particDir/ses-Post/fmap
                fi
				# Same as with Baseline. For BIDS format, these P -> A files will go in the fmap folder as acq-PtoA_epi
                dcm2niix -b y -ba y -f sub-"$partic"_ses-Post_epi -o $particDir/ses-Post/fmap "$dtiPAPostTXDir" # Follow up with Adam
				sed -i '/COL/ a "IndendedFor": ["func/sub-$partic_ses-Post_task-resting_bold.nii", "func/sub-$partic_ses-Post_task-msit_bold.nii","func/sub-$partic_ses-Post_task-nback_bold.nii","dwi/sub-$partic_ses-Post_dwi.nii"],' $particDir/ses-Post/fmap/*epi.json
              fi
            fi
            if [ "$legacyBool" = "True" ]; then
              bval=`find $particDir/dti/PostTX -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
              bvec=`find $particDir/dti/PostTX -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
            else
              bval=`find $particDir/ses-Post/dwi -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
              bvec=`find $particDir/ses-Post/dwi -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
            fi
            if [[ "${bval}" = *"bval"* ]]; then
              if [ "$legacyBool" = "True" ]; then
                mv $bval $particDir/dti/PostTX/bvals
              else
				cp $bval $particDir/ses-Post/sub-${partic}_ses-Post_run0${dtiAPPostTXNum}_dwi.bval
                mv $bval $particDir/ses-Post/dwi/bvals
              fi
            else
              echo "###### bval not found ######"
            fi
            if [[ "${bvec}" = *"bvec"* ]]; then
              if [ "$legacyBool" = "True" ]; then
                mv $bvec $particDir/dti/PostTX/bvecs
              else
			  	cp $bvec $particDir/ses-Post/sub-${partic}_ses-Post_run0${dtiAPPostTXNum}_dwi.bvec
                mv $bvec $particDir/ses-Post/dwi/bvecs
              fi
            else
              echo "###### bvec not found ######"
            fi
          else
            echo "###### No DTI images found for $partic PostTX ######"
          fi
        fi
      else
        echo "DTI images are not taken for $study"
      fi
      echo "Finished transfer and conversion for $partic"

################################################################################
    # Non-logitudinal structuring
    else
      echo "Non-logitudinal study detected."
      if [ $dirAlreadyExists -eq 1 ]; then
        if [ $bypassIndivOverwrite -eq 0 ]; then
          echo "The indiv_analysis directory already exists."
          echo "Would you like to copy and possibly overwrite your indiv_analysis images?"
          read overwritePartic
        fi
        if [[ "$overwritePartic" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
          echo "Continuing with copy..."
          if [ $overwriteLongCount = 0 ]; then
            overwriteLongCount=$((overwriteLongCount + 1))
            echo "It appears that there are a number of overwritable indiv_analysis directories which you have chosen."
            echo "Would you like to overwrite all future indiv_analysis directories and bypass the prompt?"
            read overwriteIndivResponse
            if [[ "$overwriteIndivResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
              bypassIndivOverwrite=1
            fi
          fi
          overwriteIndivCount=$((overwriteIndivCount + 1))
        else
          particBool=0
        fi
      fi
      #T1
      echo "Running dcm2nii for T1 Anatomicals"
      anatDirArr=($(find $particRawDir -maxdepth 2 -iname "T1_MPRAGE_1MM*" -print | sort))
      anatNum=1
      if [ "$legacyBool" = "True" ]; then
        if [ ! -d $particDir/anatomicals ]; then
          mkdir -p $particDir/anatomicals
        fi
        for anatomical in ${anatDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
          dcm2niix -f "$partic"_anatomical_$anatNum -o $particDir/anatomicals "${anatomical}"
          anatNum=$((anatNum+1))
        done
      else
        if [ ! -d $particDir/anat ]; then
          mkdir -p $particDir/anat
        fi
        for anatomical in ${anatDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
          dcm2niix -b y -ba y -f sub-"$partic"_run-$anatNum"_T1w" -o $particDir/anat "${anatomical}"
          anatNum=$((anatNum+1))
        done
      fi

      #T2

      echo "Running dcm2nii for T2 Anatomicals"
      anatBDirArr=($(find $particRawDir -maxdepth 2 -iname "*FLAIR*" -print | sort))
      anatNumB=1
      if [ "$legacyBool" = "True" ]; then
        if [ ! -d $particDir/anatomicals ]; then
          mkdir -p $particDir/anatomicals
        fi
        for anatomical in ${anatBDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNumB located in $anatomical"
          dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals "${anatomical}"
          anatNumB=$((anatNumB+1))
        done
      else
        if [ ! -d $particDir/anat ]; then
          mkdir -p $particDir/anat
        fi
        for anatomical in ${anatBDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNumB located in $anatomical"
          dcm2niix -b y -ba y -f sub-"$partic"_run-$anatNum"_FLAIR" -o $particDir/anat "${anatomical}"
          anatNumB=$((anatNumB+1))
        done
      fi

      if [ ${#boldValues[@]} -eq 0 ]; then
        echo "No BOLD values for $partic"
      else
        echo "Running BOLD for $partic"
        for bold_type in ${boldValues[*]}; do
          # If task directory exists run dcm2niix on it
          boldCheckString=`find $particRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
          if [[ "${boldCheckString,,}" = *"${bold_type,,}"* ]]; then
            boldDir=`find $particRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
            if [ "$legacyBool" = "True" ]; then
              # Makes directory if it doesn't exist
              if [ ! -d $particDir/bold/${bold_type} ]; then
                mkdir -p $particDir/bold/${bold_type}
              fi
              dcm2niix -f "$partic"_${bold_type} -o $particDir/bold/${bold_type} "$boldDir"
            else
              if [ ! -d $particDir/func ]; then
                mkdir -p $particDir/func
              fi
              dcm2niix -b y -ba y -f sub-"$partic"_task-${bold_type}_bold -o $particDir/func "$boldDir"
            fi
          else
            echo "No data for $bold_type in $partic directory."
          fi
        done
      fi

      if [ $magPhaseBool -eq 1 ]; then
        fieldCheckString=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
        if [[ "${fieldCheckString}" = *"field"* ]]; then
          # Running for Mag (note the sort -r)
          echo "Beginning Magnitude-Phase fieldmap conversion..."

          magDir=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort -r | tail -1`
          if [ "$legacyBool" = "True" ]; then
            if [ ! -d $particDir/fieldmaps ]; then
              mkdir -p $particDir/fieldmaps
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -f "$partic"_Mag -o $particDir/fieldmaps "$magDir"
          else
            if [ ! -d $particDir/fmap ]; then
              mkdir -p $particDir/fmap
            fi
            echo "Running dcm2nii for Mag fieldmaps"
            dcm2niix -b y -ba y -f sub-"$partic"_magnitude1 -o $particDir/fmap "$magDir"
          fi

          magCheckString=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
          if [ "$magDir" = "$magCheckString" ]; then
            echo "Only one fieldmap was found. Verify files."
          else
            # Running same system for Phase
            phaseDir=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
            if [ "$legacyBool" = "True" ]; then
              echo "Running dcm2nii for Phase fieldmaps"
              dcm2niix -f "$partic"_Phase -o $particDir/fieldmaps "$phaseDir"
            else
              echo "Running dcm2nii for Phase fieldmaps"
              dcm2niix -b y -ba y -f sub-"$partic"_phasediff -o $particDir/fmap "$phaseDir"
            fi
          fi
        else
          echo "No Magnitude or Phase fieldmaps found for $partic"
        fi
      else
        echo "Magnitude or Phase fieldmaps are not taken for $study"
      fi
      if [ $dtiBool -eq 1 ]; then
        dtiCheckString=`find $particRawDir -maxdepth 2 -iname "*dti*" -print | sort | tail -1`
        if [[ "${dtiCheckString,,}" = *"dti"* ]]; then
          # Running for DTI A -> P (note the sort -r)
          echo "Beginning DTI conversion..."

          dtiAPDir=`find $particRawDir -maxdepth 2 -iname "*dti*" -print | sort -r | tail -1`
          if [ "$legacyBool" = "True" ]; then
            if [ ! -d $particDir/dti ]; then
              mkdir -p $particDir/dti
            fi
            echo "Running dcm2nii for DTI A -> P"
            dcm2niix -f "$partic"_A2P -o $particDir/dti "$dtiAPDir"
          else
            if [ ! -d $particDir/dwi ]; then
              mkdir -p $particDir/dwi
            fi
            echo "Running dcm2nii for DTI A -> P"
            dcm2niix -b y -ba y -f sub-"$partic"_acq-AtoP_dwi -o $particDir/dwi "$dtiAPDir"
          fi

          # Running same system for DTI P -> A
          dtiPADir=`find $particRawDir -maxdepth 2 -iname "*P-?A*" -print | sort | tail -1`
          if [ "$dtiPADir" == "x$dtiPADir" ]; then
            echo "P->A file not found, searching P__A"
            dtiPADir=`find $particRawDir -maxdepth 2 -iname "*P_?A*" -print | sort | tail -1`
            if [ "$dtiPADir" == "x$dtiPADir" ]; then
              echo "P__A file not found, searching bzero identifier"
              dtiPADir=`find $particRawDir -maxdepth 2 -iname "*bzero*" -print | sort | tail -1`
            fi
          fi
          if [ "$dtiAPDir" == "$dtiPADir" ]; then
            echo "###### A -> P and P -> A mismatch for $partic, verify folders exist. ######"
          else
            if [ "$legacyBool" = "True" ]; then
              echo "Running dcm2nii for DTI P -> A"
              dcm2niix -f "$partic"_P2A -o $particDir/dti "$dtiPADir"
            else
              echo "Running dcm2nii for DTI P -> A"
              dcm2niix -b y -ba y -f sub-"$partic"_acq-PtoA_dwi -o $particDir/dwi "$dtiPADir"
            fi
          fi
          bval=`find $particDir/dti -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
          bvec=`find $particDir/dti -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
          if [[ "${bval}" = *"bval"* ]]; then
            if [ "$legacyBool" = "True" ]; then
              mv $bval $particDir/dti/bvals
            else
              mv $bval $particDir/dwi/bvals
            fi
          else
            echo "###### bval not found ######"
          fi
          if [[ "${bvec}" = *"bvec"* ]]; then
            if [ "$legacyBool" = "True" ]; then
              mv $bvec $particDir/dti/bvecs
            else
              mv $bval $particDir/dwi/bvals
            fi
          else
            echo "###### bvec not found ######"
          fi
        else
          echo "No DTI images found for $partic"
        fi
      else
        echo "DTI images are not taken for $study"
      fi
      echo "-----------------------------------------------"
      echo "Finished transfer and conversion for $partic"
      echo "-----------------------------------------------"
    fi
  fi
done
################################################################################

echo "Finished all participants."
